# 进程

## 进程状态

进程常见的状态:
S:          Interruptible Sleeping,即可中断睡眠
D:          Uninterruptible Sleeping,即不可中断睡眠
R:          Running or Runnable,即运行状态
Z:          Zombie,即僵尸状态
T:          Stopped or Traced,即中止状态(注意是"中止"而非"终止")

## 进程信息

Linux在启动一个进程时，系统会在/proc下创建一个以PID命名的文件夹，在该文件夹下会保存进程的信息
ls -l /proc/PID

cwd				符号链接的是进程运行目录
exe				符号连接就是执行程序的绝对路径
cmdline			就是程序运行时输入的命令行命令
environ			记录了进程运行时的环境变量
fd				目录下是进程打开或使用的文件的符号连接

## 创建新的进程

fork、vfork和clone三个用户态函数均由libc库提供,它们分别会调用Linux内核提供的同名系统调用fork,vfork和clone。下面以fork系统调用为例来介绍。传统的创建一个新进程的方式是子进程拷贝父进程所有资源,这无疑使得进程的创建效率低,因为子进程需要拷贝父进程的整个地址空间。更糟糕的是,如果子进程创建后又立马去执行exec族函数,那么刚刚才从父进程那里拷贝的地址空间又要被清除以便装入新的进程映像。为了解决这个问题,内核中提供了上述三种不同的系统调用。

1. 内核采用写时复制技术对传统的fork函数进行了下面的优化。即子进程创建后,父子以只读的方式共享父进程的资源(并不包括父进程的页表项)。当子进程需要修改进程地址空间的某一页时,才为子进程复制该页。采用这样的技术可以避免对父进程中某些数据不必要的复制。
2. 使用vfork函数创建的子进程会完全共享父进程的地址空间,甚至是父进程的页表项。父子进程任意一方对任何数据的修改使得另一方都可以感知到。为了使得双方不受这种影响,vfork函数创建了子进程后,父进程便被阻塞直至子进程调用了exec()或exit()。由于现在fork函数引入了写时复制技术,在不考虑复制父进程页表项的情况下,vfork函数几乎不会被使用。
3. clone函数创建子进程时灵活度比较大,因为它可以通过传递不同的clone标志参数来选择性的复制父进程的资源。
